<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tpotracer - Leaderboard</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="icon" type="image/png" href="/tpotracericon.png" />
    <link rel="apple-touch-icon" href="/tpotracericon.png" />
    
    <!-- Primary Meta Tags -->
    <meta name="title" content="tpotracer - Leaderboard" />
    <meta name="description" content="View the tpotracer typing leaderboard" />
    <meta name="theme-color" content="#02182D" />
    
    <style>
        @font-face {
            font-family: 'ProggyCleanTT';
            src: url('/ProggyClean.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            --tr-100: #A7F1FA;
            --tr-150: #77DFF6;
            --tr-200: #2A8FC3;
            --tr-250: #0d3f62;
            --tr-300: #03223F;
            --tr-400: #02182D;
        }

        body {
            font-family: 'ProggyCleanTT', 'Roboto Mono', monospace;
            background-color: var(--tr-300);
            height: 100vh;
            overflow: hidden;
            color: var(--tr-100);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px;
        }

        .back-button {
            position: fixed;
            top: 12px;
            left: 12px;
            font-size: 20px;
            color: var(--tr-100);
            text-decoration: none;
            text-shadow: 0 0 8px var(--tr-100);
            transition: opacity 0.15s ease;
            z-index: 100;
        }

        .back-button:hover {
            opacity: 0.7;
        }

        .leaderboard-wrapper {
            width: 100%;
            max-width: 800px;
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
        }

        .leaderboard-header {
            text-align: center;
            margin-bottom: 8px;
        }

        .leaderboard-logo {
            width: 140px;
            height: auto;
            margin-bottom: 12px;
            filter: drop-shadow(0 0 0.125vh var(--tr-100)) drop-shadow(0 0 0.25vh var(--tr-100));
        }

        .leaderboard-title {
            font-size: 52px;
            color: var(--tr-100);
            text-shadow: 0 0 6px var(--tr-100);
            margin-bottom: 8px;
            font-weight: normal;
            letter-spacing: 4px;
        }

        .leaderboard-countdown {
            font-size: 24px;
            color: var(--tr-200);
            text-shadow: 0 0 4px var(--tr-200);
        }

        .table-header {
            display: flex;
            align-items: center;
            padding: 8px 22px 8px 16px;
            font-size: 22px;
            color: var(--tr-100);
            text-shadow: 0 0 2px var(--tr-100);
            border-bottom: 1px solid rgba(167, 241, 250, 0.2);
            background: rgba(3, 34, 63, 0.8);
            backdrop-filter: blur(4px);
        }

        .col-rank {
            width: 70px;
            text-align: center;
            flex-shrink: 0;
        }

        .col-user {
            flex: 1;
            text-align: left;
            padding-left: 8px;
        }

        .col-wpm {
            width: 100px;
            text-align: right;
            padding-right: 12px;
            flex-shrink: 0;
        }
        
        .col-raw {
            width: 80px;
            text-align: center;
            flex-shrink: 0;
        }
        
        .col-acc {
            width: 80px;
            text-align: center;
            flex-shrink: 0;
        }
        
        .col-replay {
            width: 60px;
            text-align: center;
            flex-shrink: 0;
            display: flex;
            justify-content: center;
        }
        
        .replay-btn {
            background: none;
            border: none;
            cursor: pointer;
            color: var(--tr-100);
            opacity: 0.5;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 6px;
            border-radius: 50%;
        }
        
        .replay-btn:hover {
            opacity: 1;
            background: rgba(167, 241, 250, 0.1);
            box-shadow: 0 0 10px rgba(167, 241, 250, 0.3);
        }

        .current-user-row {
            display: flex;
            align-items: center;
            padding: 8px 22px 8px 16px;
            font-size: 22px;
            color: var(--tr-100);
            text-shadow: 0 0 3px var(--tr-100);
            position: sticky;
            top: 0;
            z-index: 10;
            background: linear-gradient(
                to right, 
                rgba(167, 241, 250, 0) 0%, 
                rgba(167, 241, 250, 0.15) 10%, 
                rgba(167, 241, 250, 0.15) 90%, 
                rgba(167, 241, 250, 0) 100%
            );
            backdrop-filter: blur(8px);
            border-bottom: 1px solid rgba(167, 241, 250, 0.1);
        }

        .current-user-row.guest-row {
            opacity: 0.6;
        }

        .leaderboard-list {
            flex: 1;
            overflow-y: scroll;
            overflow-x: hidden;
            padding-bottom: 20px;
        }

        .leaderboard-row {
            display: flex;
            align-items: center;
            padding: 8px 16px;
            font-size: 22px;
            transition: background 0.15s ease;
        }

        .leaderboard-row:hover {
            background: rgba(167, 241, 250, 0.05);
        }

        .rank-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 36px;
            height: 28px;
            padding: 0 6px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 22px;
        }

        .rank-badge-plain {
            background-color: rgba(167, 241, 250, 0.2);
            box-shadow: 0 0 3px rgba(167, 241, 250, 0.3);
            color: var(--tr-100);
            text-shadow: 0 0 2px var(--tr-100);
        }

        .rank-badge-1 {
            background: linear-gradient(to bottom, #ffd700 0%, #b8860b 90%, #ffd700 100%);
            box-shadow: 0 0 4px #ffd700;
            color: #fff;
            text-shadow: 0 0 2px #fff;
        }

        .rank-badge-2 {
            background: linear-gradient(to bottom, #c0c0c0 0%, #808080 90%, #c0c0c0 100%);
            box-shadow: 0 0 4px #c0c0c0;
            color: #fff;
            text-shadow: 0 0 2px #fff;
        }

        .rank-badge-3 {
            background: linear-gradient(to bottom, #cd7f32 0%, #8b4513 90%, #cd7f32 100%);
            box-shadow: 0 0 4px #cd7f32;
            color: #fff;
            text-shadow: 0 0 2px #fff;
        }

        .user-link {
            display: flex;
            align-items: center;
            gap: 10px;
            color: inherit;
            text-decoration: none;
        }

        .user-link:hover .username {
            text-decoration: underline;
        }

        .user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-color: rgba(167, 241, 250, 0.2);
            background-size: cover;
            background-position: center;
            position: relative;
            flex-shrink: 0;
        }

        .user-avatar::before {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 50%;
            background: inherit;
            background-size: cover;
            background-position: center;
            filter: blur(4px);
            opacity: 0.6;
            z-index: -1;
        }

        .username {
            text-shadow: 0 0 2px var(--tr-100);
        }

        .wpm-value {
            text-shadow: 0 0 2px var(--tr-100);
            font-variant-numeric: tabular-nums;
        }
        
        .wpm-decimal {
            font-size: 0.65em;
            opacity: 0.8;
            margin-left: 1px;
        }
        
        .raw-value, .acc-value {
            opacity: 0.8;
            font-size: 20px;
        }

        .loading-row {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px 16px;
            font-size: 22px;
            color: var(--tr-100);
            text-shadow: 0 0 2px var(--tr-100);
            opacity: 0.6;
        }

        .empty-state {
            text-align: center;
            padding: 80px 20px;
            color: var(--tr-200);
            font-size: 26px;
            text-shadow: 0 0 2px var(--tr-200);
            opacity: 0.7;
        }

        /* Scrollbar styling */
        .leaderboard-list::-webkit-scrollbar {
            width: 6px;
        }

        .leaderboard-list::-webkit-scrollbar-track {
            background: rgba(167, 241, 250, 0.05);
            border-radius: 3px;
        }

        .leaderboard-list::-webkit-scrollbar-thumb {
            background: rgba(167, 241, 250, 0.2);
            border-radius: 3px;
        }

        .leaderboard-list::-webkit-scrollbar-thumb:hover {
            background: rgba(167, 241, 250, 0.3);
        }

        /* Leaderboard container with circular radial gradient */
        .leaderboard-container {
            position: relative;
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--tr-300);
            border-radius: 12px;
            border: 1px solid rgba(167, 241, 250, 0.15);
            overflow: hidden;
            min-height: 0;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .loading-dots {
            animation: pulse 1.2s ease-in-out infinite;
        }

        /* Responsive adjustments */
        @media (max-width: 640px) {
            body {
                padding: 16px;
            }

            .back-button {
                top: 16px;
                left: 16px;
                font-size: 16px;
            }

            .leaderboard-logo {
                width: 140px;
                margin-bottom: 12px;
            }

            .leaderboard-title {
                font-size: 36px;
                letter-spacing: 2px;
                margin-bottom: 8px;
            }

            .leaderboard-countdown {
                font-size: 22px;
            }

            .leaderboard-header {
                margin-bottom: 20px;
            }

            .table-header,
            .current-user-row,
            .leaderboard-row {
                font-size: 18px;
                padding: 10px 12px;
            }

            .col-rank {
                width: 50px;
            }

            .col-wpm {
                width: 70px;
            }
            
            .col-raw, .col-acc {
                width: 50px;
                font-size: 16px;
            }
            
            .raw-value, .acc-value {
                font-size: 16px;
            }

            .rank-badge {
                min-width: 28px;
                height: 22px;
                font-size: 16px;
            }

            .user-avatar {
                width: 24px;
                height: 24px;
            }

            .user-link {
                gap: 6px;
            }
            
            .col-replay {
                width: 40px;
            }
            
            .replay-btn svg {
                width: 16px;
                height: 16px;
            }
        }
        
        /* Replay Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(2, 24, 45, 0.85);
            backdrop-filter: blur(8px);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        .modal-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-content {
            background: var(--tr-300);
            border: 1px solid var(--tr-150);
            border-radius: 12px;
            padding: 24px;
            width: 90%;
            max-width: 900px;
            position: relative;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .close-modal {
            position: absolute;
            top: 16px;
            right: 16px;
            background: none;
            border: none;
            color: var(--tr-100);
            font-family: inherit;
            font-size: 32px;
            line-height: 1;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
            z-index: 10;
        }

        .close-modal:hover {
            opacity: 1;
        }

        .replay-header {
            text-align: center;
            margin-bottom: 10px;
        }
        
        .replay-stats {
            display: flex;
            gap: 20px;
            justify-content: center;
            font-size: 20px;
            color: var(--tr-150);
            margin-top: 8px;
        }
        
        .replay-stats .live-stat {
            min-width: 80px;
            font-variant-numeric: tabular-nums;
        }
        
        .replay-username {
            font-size: 32px;
            color: var(--tr-100);
            text-shadow: 0 0 4px var(--tr-100);
        }
        
        /* Replay scrubber/timeline */
        .replay-controls {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 0 4px;
        }
        
        .replay-time {
            font-size: 16px;
            color: var(--tr-150);
            min-width: 45px;
            text-align: center;
            font-variant-numeric: tabular-nums;
        }
        
        .replay-scrubber {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(167, 241, 250, 0.15);
            border-radius: 4px;
            outline: none;
            cursor: pointer;
        }
        
        .replay-scrubber::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--tr-100);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 8px var(--tr-100);
            transition: transform 0.1s ease;
        }
        
        .replay-scrubber::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }
        
        .replay-scrubber::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--tr-100);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 8px var(--tr-100);
        }
        
        .replay-play-btn {
            background: none;
            border: 1px solid var(--tr-150);
            border-radius: 6px;
            color: var(--tr-100);
            cursor: pointer;
            padding: 6px 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .replay-play-btn:hover {
            background: rgba(167, 241, 250, 0.1);
            box-shadow: 0 0 8px rgba(167, 241, 250, 0.3);
        }
        
        .replay-speed {
            background: none;
            border: 1px solid var(--tr-150);
            border-radius: 4px;
            color: var(--tr-100);
            cursor: pointer;
            padding: 4px 8px;
            font-family: inherit;
            font-size: 14px;
            min-width: 50px;
            text-align: center;
            transition: all 0.2s ease;
        }
        
        .replay-speed:hover {
            background: rgba(167, 241, 250, 0.1);
        }
        
        .replay-finished-badge {
            display: inline-block;
            padding: 2px 8px;
            background: rgba(74, 222, 128, 0.2);
            border: 1px solid rgba(74, 222, 128, 0.5);
            border-radius: 4px;
            font-size: 14px;
            color: #4ade80;
            margin-left: 8px;
        }

        .replay-container {
            background: rgba(0, 0, 0, 0.3);
            padding: 32px;
            border-radius: 8px;
            font-size: 28px;
            line-height: 1.8;
            height: 300px;
            overflow-y: auto;
            position: relative;
            font-family: 'ProggyCleanTT', monospace;
            display: flex;
            flex-wrap: wrap;
            gap: 0.7em; /* Space between words */
            align-content: flex-start;
        }
        
        .word {
            display: inline-flex;
            white-space: nowrap;
        }

        .char {
            color: #6b7280; /* gray-500 */
        }
        
        .char.correct {
            color: #4ade80; /* green-400 */
            text-shadow: 0 0 2px rgba(74, 222, 128, 0.5);
        }
        
        .char.incorrect {
            color: #ef4444; /* red-500 */
            text-shadow: 0 0 2px rgba(239, 68, 68, 0.5);
        }
        
        .char.extra {
            color: #ef4444; /* red-500 */
        }
        
        .cursor {
            width: 2px;
            height: 1.2em;
            background-color: var(--tr-100);
            box-shadow: 0 0 4px var(--tr-100);
            position: absolute;
            transition: left 0.05s linear, top 0.05s linear;
            pointer-events: none;
            margin-top: 0.2em;
        }

        /* Compact Mode Styles */
        .compact-mode .table-header,
        .compact-mode .current-user-row,
        .compact-mode .leaderboard-row {
            padding: 4px 16px;
            font-size: 18px;
        }

        .compact-mode .table-header,
        .compact-mode .current-user-row {
            padding: 4px 22px 4px 16px;
        }

        .compact-mode .rank-badge {
            min-width: 28px;
            height: 22px;
            font-size: 16px;
            padding: 0 4px;
        }

        .compact-mode .user-avatar {
            width: 24px;
            height: 24px;
        }
        
        .compact-mode .raw-value, 
        .compact-mode .acc-value {
            font-size: 16px;
        }

        .compact-mode .replay-btn svg {
            width: 16px;
            height: 16px;
        }

        .compact-toggle-container {
            display: flex;
            justify-content: flex-end;
            margin-bottom: 4px;
            width: 100%;
            padding-right: 4px;
        }

        .compact-toggle-label {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--tr-100);
            font-size: 18px;
            cursor: pointer;
            user-select: none;
            text-shadow: 0 0 2px var(--tr-100);
            opacity: 0.8;
            transition: opacity 0.2s;
        }

        .compact-toggle-label:hover {
            opacity: 1;
        }

        .compact-checkbox {
            appearance: none;
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border: 2px solid var(--tr-100);
            border-radius: 3px;
            background: transparent;
            cursor: pointer;
            position: relative;
            outline: none;
        }

        .compact-checkbox:checked {
            background: var(--tr-100);
            box-shadow: 0 0 4px var(--tr-100);
        }

        .compact-checkbox:checked::after {
            content: '✓';
            position: absolute;
            color: var(--tr-300);
            font-size: 14px;
            top: -2px;
            left: 1px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <a href="/" class="back-button">← back to game</a>

    <div class="leaderboard-wrapper">
        <div class="leaderboard-header">
            <img src="/logosm.png" alt="tpotracer" class="leaderboard-logo" />
            <div class="leaderboard-countdown" id="countdown">-0:00:00:00</div>
        </div>

        <div class="compact-toggle-container">
            <label class="compact-toggle-label">
                <input type="checkbox" id="compact-toggle" class="compact-checkbox">
                Compact Mode
            </label>
        </div>

        <div class="leaderboard-container" id="leaderboard-container">
            <div class="table-header">
                <div class="col-rank">#</div>
                <div class="col-user">USERNAME</div>
                <div class="col-wpm">WPM</div>
                <div class="col-raw">RAW</div>
                <div class="col-acc">ACC</div>
                <div class="col-replay"></div>
            </div>

            <div class="current-user-row" id="current-user-row">
                <div class="col-rank">
                    <span class="rank-badge rank-badge-plain" id="current-rank">-</span>
                </div>
                <div class="col-user">
                    <a href="#" class="user-link" id="current-user-link" target="_blank" rel="noopener noreferrer">
                        <span class="user-avatar" id="current-avatar"></span>
                        <span class="username" id="current-username">@guest</span>
                    </a>
                </div>
                <div class="col-wpm">
                    <span class="wpm-value" id="current-wpm">0</span>
                </div>
                <div class="col-raw">
                    <span class="raw-value" id="current-raw">-</span>
                </div>
                <div class="col-acc">
                    <span class="acc-value" id="current-acc">-</span>
                </div>
                <div class="col-replay">
                    <button class="replay-btn" id="current-replay-btn" title="Watch Replay">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="5 3 19 12 5 21 5 3"></polygon>
                        </svg>
                    </button>
                </div>
            </div>

            <div class="leaderboard-list" id="leaderboard-list">
                <div class="loading-row">
                    <span class="loading-dots">Loading...</span>
                </div>
            </div>
        </div>
    </div>

    <div id="replay-modal" class="modal-overlay">
        <div class="modal-content">
            <button class="close-modal" id="close-replay">×</button>
            <div class="replay-header">
                <div class="replay-username" id="replay-username">@user</div>
                <div class="replay-stats">
                    <span class="live-stat">WPM: <span id="replay-wpm">0</span></span>
                    <span class="live-stat">RAW: <span id="replay-raw">0</span></span>
                    <span class="live-stat">ACC: <span id="replay-acc">100%</span></span>
                </div>
            </div>
            <div class="replay-controls">
                <button class="replay-play-btn" id="replay-play-btn" title="Play/Pause">
                    <svg id="play-icon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="5 3 19 12 5 21 5 3"></polygon>
                    </svg>
                    <svg id="pause-icon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
                        <rect x="6" y="4" width="4" height="16"></rect>
                        <rect x="14" y="4" width="4" height="16"></rect>
                    </svg>
                </button>
                <span class="replay-time" id="replay-time-current">0.0s</span>
                <input type="range" class="replay-scrubber" id="replay-scrubber" min="0" max="100" value="0" step="0.1">
                <span class="replay-time" id="replay-time-total">0.0s</span>
                <button class="replay-speed" id="replay-speed" title="Playback Speed">1x</button>
            </div>
            <div id="replay-container" class="replay-container">
                <!-- Words injected here -->
                <div id="replay-cursor" class="cursor"></div>
            </div>
        </div>
    </div>

    <script type="module">
        // === CONFIGURATION ===
        const PAGE_SIZE = 50;
        const TIME_LIMIT = new Date('2026-01-04T20:00:00Z');
        
        // Access Environment Variables
        const API_KEY = import.meta.env.VITE_API_KEY;
        const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || '';
        
        // === STATE ===
        let leaderboardData = [];
        let isLoading = false;
        let hasMore = true;
        let currentUser = null;
        let userRank = null;
        let userWpm = 0;
        let userRaw = null;
        let userAcc = null;

        // === DOM ELEMENTS ===
        const countdownEl = document.getElementById('countdown');
        const currentUserRow = document.getElementById('current-user-row');
        const currentRankEl = document.getElementById('current-rank');
        const currentUsernameEl = document.getElementById('current-username');
        const currentAvatarEl = document.getElementById('current-avatar');
        const currentWpmEl = document.getElementById('current-wpm');
        const currentRawEl = document.getElementById('current-raw');
        const currentAccEl = document.getElementById('current-acc');
        const currentUserLink = document.getElementById('current-user-link');
        const listEl = document.getElementById('leaderboard-list');
        const currentReplayBtn = document.getElementById('current-replay-btn');
        const leaderboardContainer = document.getElementById('leaderboard-container');
        const compactToggle = document.getElementById('compact-toggle');
        
        // Replay Modal Elements
        const replayModal = document.getElementById('replay-modal');
        const closeReplayBtn = document.getElementById('close-replay');
        const replayContainer = document.getElementById('replay-container');
        const replayUsernameEl = document.getElementById('replay-username');
        const replayWpmEl = document.getElementById('replay-wpm');
        const replayRawEl = document.getElementById('replay-raw');
        const replayAccEl = document.getElementById('replay-acc');
        const replayCursor = document.getElementById('replay-cursor');
        const replayPlayBtn = document.getElementById('replay-play-btn');
        const playIcon = document.getElementById('play-icon');
        const pauseIcon = document.getElementById('pause-icon');
        const replayScrubber = document.getElementById('replay-scrubber');
        const replayTimeCurrent = document.getElementById('replay-time-current');
        const replayTimeTotal = document.getElementById('replay-time-total');
        const replaySpeedBtn = document.getElementById('replay-speed');
        
        let replayAnimationId = null;
        let replayState = null; // Will hold all replay state

        // === UTILITY FUNCTIONS ===
        function getRemainingTimeUntilEnd() {
            const now = new Date();
            const timeLeft = TIME_LIMIT.getTime() - now.getTime();
            
            if (timeLeft <= 0) {
                return "-0:00:00:00";
            }
            
            const days = Math.floor(timeLeft / (1000 * 60 * 60 * 24));
            const hours = Math.floor((timeLeft % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);
            
            const pad = (num) => num.toString().padStart(2, '0');
            return `-${days}:${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
        }

        function getBadgeClass(place) {
            if (place === 1) return 'rank-badge-1';
            if (place === 2) return 'rank-badge-2';
            if (place === 3) return 'rank-badge-3';
            return 'rank-badge-plain';
        }

        function setAvatarBackground(element, username) {
            if (username && username !== 'guest') {
                const avatarUrl = `https://unavatar.io/x/${username}`;
                element.style.backgroundImage = `url(${avatarUrl})`;
            }
        }
        
        function formatWpm(wpm) {
            const val = parseFloat(wpm);
            const integerPart = Math.floor(val);
            const decimalPart = (val - integerPart).toFixed(2).substring(1); // .xx
            return `${integerPart}<span class="wpm-decimal">${decimalPart}</span>`;
        }

        // === API FUNCTIONS ===
        // Use relative URLs - Vite proxy handles in dev, deployment handles in prod
        async function fetchLeaderboardPage(offset = 0) {
            try {
                const headers = {};
                if (API_KEY) headers['x-api-key'] = API_KEY;

                const response = await fetch(`${API_BASE_URL}/api/leaderboard?limit=${PAGE_SIZE}&offset=${offset}`, { headers });
                if (response.ok) {
                    return await response.json();
                }
                console.log('API response not ok:', response.status);
            } catch (e) {
                console.log('API fetch failed:', e);
            }
            
            return [];
        }

        async function fetchUserRank(username) {
            if (!username || username === 'guest') return null;
            
            try {
                const headers = {};
                if (API_KEY) headers['x-api-key'] = API_KEY;

                const response = await fetch(`${API_BASE_URL}/api/rank/${encodeURIComponent(username)}`, { headers });
                if (response.ok) {
                    return await response.json();
                }
            } catch (e) {
                console.log('Rank fetch failed:', e);
            }
            
            return null;
        }
        
        async function fetchReplayData(username) {
            try {
                const headers = {};
                if (API_KEY) headers['x-api-key'] = API_KEY;

                const response = await fetch(`${API_BASE_URL}/api/replay/${encodeURIComponent(username)}`, { headers });
                if (response.ok) {
                    return await response.json();
                }
            } catch (e) {
                console.error('Replay fetch failed:', e);
            }
            return null;
        }

        // === RENDER FUNCTIONS ===
        function renderLeaderboardRow(entry, rank) {
            const row = document.createElement('div');
            row.className = 'leaderboard-row';
            
            const rawWpm = entry.raw_wpm !== undefined ? Math.round(entry.raw_wpm) : '-';
            const accuracy = entry.accuracy !== undefined ? Math.round(entry.accuracy) + '%' : '-';
            
            row.innerHTML = `
                <div class="col-rank">
                    <span class="rank-badge ${getBadgeClass(rank)}">${rank}</span>
                </div>
                <div class="col-user">
                    <a href="https://x.com/${entry.username}" class="user-link" target="_blank" rel="noopener noreferrer">
                        <span class="user-avatar" data-username="${entry.username}"></span>
                        <span class="username">@${entry.username}</span>
                    </a>
                </div>
                <div class="col-wpm">
                    <span class="wpm-value" title="${parseFloat(entry.wpm).toFixed(3)}">${formatWpm(entry.wpm)}</span>
                </div>
                <div class="col-raw">
                    <span class="raw-value">${rawWpm}</span>
                </div>
                <div class="col-acc">
                    <span class="acc-value">${accuracy}</span>
                </div>
                <div class="col-replay">
                    <button class="replay-btn" onclick="openReplay('${entry.username}')" title="Watch Replay">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="5 3 19 12 5 21 5 3"></polygon>
                        </svg>
                    </button>
                </div>
            `;
            
            // Set avatar
            const avatar = row.querySelector('.user-avatar');
            setAvatarBackground(avatar, entry.username);
            
            return row;
        }

        function renderLoadingRow() {
            const row = document.createElement('div');
            row.className = 'loading-row';
            row.innerHTML = '<span class="loading-dots">Loading...</span>';
            return row;
        }

        function updateCurrentUser() {
            if (!currentUser || currentUser === 'guest') {
                currentUserRow.classList.add('guest-row');
                currentRankEl.textContent = '-';
                currentRankEl.className = 'rank-badge rank-badge-plain';
                currentUsernameEl.textContent = '@guest';
                currentWpmEl.innerHTML = '0<span class="wpm-decimal">.00</span>';
                currentRawEl.textContent = '-';
                currentAccEl.textContent = '-';
                currentUserLink.href = '#';
                currentUserLink.onclick = (e) => e.preventDefault();
                currentReplayBtn.style.display = 'none';
            } else {
                currentUserRow.classList.remove('guest-row');
                currentRankEl.textContent = userRank || '-';
                currentRankEl.className = `rank-badge ${getBadgeClass(userRank || 999)}`;
                currentUsernameEl.textContent = `@${currentUser}`;
                currentWpmEl.innerHTML = formatWpm(userWpm);
                currentWpmEl.title = typeof userWpm === 'number' ? userWpm.toFixed(3) : userWpm;
                currentRawEl.textContent = userRaw !== null ? Math.round(userRaw) : '-';
                currentAccEl.textContent = userAcc !== null ? Math.round(userAcc) + '%' : '-';
                
                currentUserLink.href = `https://x.com/${currentUser}`;
                currentUserLink.onclick = null;
                setAvatarBackground(currentAvatarEl, currentUser);
                
                currentReplayBtn.style.display = 'flex';
                currentReplayBtn.onclick = () => openReplay(currentUser);
            }
        }

        function renderLeaderboard() {
            listEl.innerHTML = '';
            
            if (leaderboardData.length === 0 && !isLoading) {
                listEl.innerHTML = '<div class="empty-state">No entries yet</div>';
                return;
            }
            
            leaderboardData.forEach((entry, index) => {
                listEl.appendChild(renderLeaderboardRow(entry, index + 1));
            });
            
            if (isLoading) {
                listEl.appendChild(renderLoadingRow());
            }
        }

        // === DATA LOADING ===
        async function loadInitialData() {
            isLoading = true;
            renderLeaderboard();
            
            try {
                const data = await fetchLeaderboardPage(0);
                leaderboardData = data;
                hasMore = data.length === PAGE_SIZE;
                
                // Also fetch user rank if we have a logged in user
                if (currentUser && currentUser !== 'guest') {
                    const rankData = await fetchUserRank(currentUser);
                    if (rankData) {
                        userRank = rankData.rank;
                        // Get WPM from leaderboard data if user is in top entries
                        const userEntry = leaderboardData.find(e => e.username === currentUser);
                        if (userEntry) {
                            userWpm = userEntry.wpm;
                            userRaw = userEntry.raw_wpm;
                            userAcc = userEntry.accuracy;
                        }
                    }
                }
                
                updateCurrentUser();
            } catch (e) {
                console.error('Failed to load leaderboard:', e);
            }
            
            isLoading = false;
            renderLeaderboard();
            checkFillScreen();
        }

        async function loadMore() {
            if (isLoading || !hasMore) return;
            
            isLoading = true;
            listEl.appendChild(renderLoadingRow());
            
            try {
                const data = await fetchLeaderboardPage(leaderboardData.length);
                leaderboardData = [...leaderboardData, ...data];
                hasMore = data.length === PAGE_SIZE;
            } catch (e) {
                console.error('Failed to load more:', e);
            }
            
            isLoading = false;
            renderLeaderboard();
            checkFillScreen();
        }

        // === REPLAY LOGIC ===
        
        // Score calculation - matches game's exact formula
        function calculateScores(correctChars, totalChars, elapsedTimeInMinutes) {
            const rawWpm = totalChars > 0 && elapsedTimeInMinutes > 0
                ? (totalChars / 5) / elapsedTimeInMinutes
                : 0;
            
            const wpm = correctChars > 0 && elapsedTimeInMinutes > 0
                ? (correctChars / 5) / elapsedTimeInMinutes
                : 0;
            
            const accuracy = totalChars > 0
                ? (correctChars / totalChars) * 100
                : 100;
            
            return { wpm, rawWpm, accuracy };
        }
        
        async function openReplay(username) {
            // Reset UI
            replayUsernameEl.textContent = 'Loading...';
            replayWpmEl.textContent = '-';
            replayRawEl.textContent = '-';
            replayAccEl.textContent = '-';
            replayContainer.innerHTML = '<div class="loading-dots" style="margin: auto; color: var(--tr-100);">Loading replay data...</div>';
            replayScrubber.value = 0;
            replayTimeCurrent.textContent = '0.0s';
            replayTimeTotal.textContent = '0.0s';
            playIcon.style.display = 'none';
            pauseIcon.style.display = 'block';
            replaySpeedBtn.textContent = '1x';
            replayModal.classList.add('visible');
            
            const data = await fetchReplayData(username);
            
            if (!data) {
                replayContainer.innerHTML = '<div style="margin: auto; color: var(--tr-200);">Replay unavailable</div>';
                replayUsernameEl.textContent = `@${username}`;
                return;
            }
            
            replayUsernameEl.textContent = `@${data.username || username}`;
            
            startReplay(data);
        }
        
        // Make openReplay available globally for onclick handlers
        window.openReplay = openReplay;
        
        function startReplay(data) {
            const words = data.words;
            const keystrokes = typeof data.keystrokes === 'string' ? JSON.parse(data.keystrokes) : data.keystrokes;
            
            if (!words || !keystrokes || keystrokes.length === 0) {
                replayContainer.innerHTML = '<div style="margin: auto; color: var(--tr-200);">Invalid replay data</div>';
                return;
            }
            
            // Build DOM structure
            replayContainer.innerHTML = '';
            const wordEls = [];
            const charEls = []; // Map: wordIndex -> charIndex -> element
            
            words.forEach((word, wIdx) => {
                const wordEl = document.createElement('div');
                wordEl.className = 'word';
                const chars = [];
                
                word.split('').forEach((char, cIdx) => {
                    const charEl = document.createElement('span');
                    charEl.className = 'char';
                    charEl.textContent = char;
                    wordEl.appendChild(charEl);
                    chars.push(charEl);
                });
                
                replayContainer.appendChild(wordEl);
                wordEls.push(wordEl);
                charEls.push(chars);
            });
            
            // Add cursor
            replayContainer.appendChild(replayCursor);
            
            // Calculate total duration from keystrokes
            const firstKeyTime = keystrokes[0].timestamp;
            const lastKeyTime = keystrokes[keystrokes.length - 1].timestamp;
            const totalDuration = lastKeyTime - firstKeyTime;
            
            // Initialize replay state
            replayState = {
                words,
                keystrokes,
                wordEls,
                charEls,
                firstKeyTime,
                totalDuration,
                currentWordIndex: 0,
                typedText: '',
                typedHistory: [],
                correctChars: 0,
                totalChars: 0,
                keyIndex: 0,
                isPlaying: true,
                playbackSpeed: 1,
                currentTime: 0, // Virtual time in ms relative to first keystroke
                lastFrameTime: performance.now(),
                isFinished: false
            };
            
            // Set up timeline
            replayTimeTotal.textContent = (totalDuration / 1000).toFixed(1) + 's';
            replayScrubber.max = totalDuration;
            replayScrubber.value = 0;
            
            // Initial render
            updateReplayUI();
            updateCursor();
            
            // Start loop
            replayAnimationId = requestAnimationFrame(replayLoop);
        }
        
        function updateCursor() {
            if (!replayState) return;
            
            const { words, wordEls, charEls, currentWordIndex, typedText } = replayState;
            
            let targetEl = null;
            let position = 'before';
            
            if (currentWordIndex >= words.length) {
                return;
            }
            
            const currentWordEl = wordEls[currentWordIndex];
            
            if (typedText.length === 0) {
                const firstChar = charEls[currentWordIndex]?.[0];
                if (firstChar) {
                    targetEl = firstChar;
                    position = 'before';
                }
            } else {
                const wordLen = words[currentWordIndex].length;
                
                if (typedText.length <= wordLen) {
                    const lastTypedChar = charEls[currentWordIndex][typedText.length - 1];
                    targetEl = lastTypedChar;
                    position = 'after';
                } else {
                    targetEl = currentWordEl.lastElementChild;
                    position = 'after';
                }
            }
            
            if (targetEl) {
                const rect = targetEl.getBoundingClientRect();
                const containerRect = replayContainer.getBoundingClientRect();
                
                let left = rect.left - containerRect.left + replayContainer.scrollLeft;
                if (position === 'after') {
                    left += rect.width;
                }
                
                const top = rect.top - containerRect.top + replayContainer.scrollTop;
                
                replayCursor.style.left = `${left}px`;
                replayCursor.style.top = `${top}px`;
                
                // Auto scroll
                if (rect.bottom > containerRect.bottom - 20) {
                    replayContainer.scrollTop += 30;
                }
            }
        }
        
        function renderWordState(wIdx) {
            if (!replayState || wIdx >= replayState.words.length) return;
            
            const { words, wordEls, charEls, currentWordIndex, typedText, typedHistory } = replayState;
            
            const targetWord = words[wIdx];
            const input = wIdx === currentWordIndex ? typedText : (typedHistory[wIdx] || '');
            const wordEl = wordEls[wIdx];
            const chars = charEls[wIdx];
            
            // Reset standard chars
            chars.forEach((charEl, cIdx) => {
                if (cIdx < input.length) {
                    if (input[cIdx] === targetWord[cIdx]) {
                        charEl.className = 'char correct';
                    } else {
                        charEl.className = 'char incorrect';
                    }
                } else {
                    charEl.className = 'char';
                }
            });
            
            // Handle extra chars
            while (wordEl.children.length > chars.length) {
                wordEl.removeChild(wordEl.lastChild);
            }
            
            if (input.length > targetWord.length) {
                const extras = input.slice(targetWord.length);
                extras.split('').forEach(char => {
                    const span = document.createElement('span');
                    span.className = 'char extra';
                    span.textContent = char;
                    wordEl.appendChild(span);
                });
            }
        }
        
        function updateReplayUI() {
            if (!replayState) return;
            
            const { currentTime, totalDuration, correctChars, totalChars, firstKeyTime, isFinished } = replayState;
            
            // Update timeline
            replayScrubber.value = currentTime;
            replayTimeCurrent.textContent = (currentTime / 1000).toFixed(1) + 's';
            
            // Calculate live stats
            const elapsedTimeInMinutes = currentTime / 1000 / 60;
            const scores = calculateScores(correctChars, totalChars, elapsedTimeInMinutes);
            
            replayWpmEl.innerHTML = totalChars > 0 ? formatWpm(scores.wpm) : '0<span class="wpm-decimal">.00</span>';
            replayRawEl.textContent = totalChars > 0 ? Math.round(scores.rawWpm) : '0';
            replayAccEl.textContent = Math.round(scores.accuracy) + '%';
        }
        
        function processKeystrokesUpTo(targetTime) {
            if (!replayState) return;
            
            const { words, keystrokes, firstKeyTime } = replayState;
            
            // Reset state if we're seeking backwards
            if (targetTime < replayState.currentTime || replayState.keyIndex === 0) {
                replayState.currentWordIndex = 0;
                replayState.typedText = '';
                replayState.typedHistory = [];
                replayState.correctChars = 0;
                replayState.totalChars = 0;
                replayState.keyIndex = 0;
                replayState.isFinished = false;
                
                // Reset all word displays
                replayState.wordEls.forEach((wordEl, wIdx) => {
                    const chars = replayState.charEls[wIdx];
                    chars.forEach(charEl => {
                        charEl.className = 'char';
                    });
                    // Remove extra chars
                    while (wordEl.children.length > chars.length) {
                        wordEl.removeChild(wordEl.lastChild);
                    }
                });
                
                replayContainer.scrollTop = 0;
            }
            
            // Process keystrokes up to target time
            while (replayState.keyIndex < keystrokes.length) {
                const k = keystrokes[replayState.keyIndex];
                const relativeTime = k.timestamp - firstKeyTime;
                
                if (relativeTime > targetTime) {
                    break;
                }
                
                processKeystroke(k);
                replayState.keyIndex++;
            }
            
            // Check if we've processed all keystrokes
            if (replayState.keyIndex >= keystrokes.length) {
                replayState.isFinished = true;
            }
            
            replayState.currentTime = targetTime;
            
            // Re-render current word
            renderWordState(replayState.currentWordIndex);
            updateCursor();
            updateReplayUI();
        }
        
        function processKeystroke(k) {
            if (!replayState) return;
            
            const { words } = replayState;
            const key = k.key;
            
            if (key === 'Backspace') {
                // Backspace is disabled in the game, but handle it for completeness
                replayState.typedText = replayState.typedText.slice(0, -1);
            } else if (key === ' ' && replayState.typedText.length > 0) {
                // Space moves to next word
                
                // Count space as a correct character when the word is typed correctly (matching game logic)
                const currentWord = words[replayState.currentWordIndex];
                if (replayState.typedText === currentWord) {
                    replayState.correctChars++;
                    replayState.totalChars++;
                }
                
                replayState.typedHistory[replayState.currentWordIndex] = replayState.typedText;
                renderWordState(replayState.currentWordIndex);
                replayState.currentWordIndex++;
                replayState.typedText = '';
                if (replayState.currentWordIndex < words.length) {
                    renderWordState(replayState.currentWordIndex);
                }
            } else if (key.length === 1) {
                // Regular character - track stats matching game logic
                const currentWord = words[replayState.currentWordIndex];
                const newTypedText = replayState.typedText + key;
                
                replayState.totalChars++;
                
                // Check if character is correct (same logic as game)
                if (newTypedText.length <= currentWord.length && 
                    currentWord[newTypedText.length - 1] === key) {
                    replayState.correctChars++;
                }
                
                replayState.typedText = newTypedText;
                renderWordState(replayState.currentWordIndex);
            }
        }
        
        function replayLoop() {
            if (!replayState || !replayState.isPlaying) {
                return;
            }
            
            const now = performance.now();
            const deltaTime = (now - replayState.lastFrameTime) * replayState.playbackSpeed;
            replayState.lastFrameTime = now;
            
            const newTime = Math.min(replayState.currentTime + deltaTime, replayState.totalDuration);
            
            // Process keystrokes up to current time
            processKeystrokesUpTo(newTime);
            
            // Continue loop if not finished
            if (!replayState.isFinished && replayState.isPlaying) {
                replayAnimationId = requestAnimationFrame(replayLoop);
            } else if (replayState.isFinished) {
                // Show finished state
                playIcon.style.display = 'block';
                pauseIcon.style.display = 'none';
                replayState.isPlaying = false;
            }
        }
        
        // Play/Pause button
        replayPlayBtn.addEventListener('click', () => {
            if (!replayState) return;
            
            if (replayState.isPlaying) {
                // Pause
                replayState.isPlaying = false;
                playIcon.style.display = 'block';
                pauseIcon.style.display = 'none';
                if (replayAnimationId) {
                    cancelAnimationFrame(replayAnimationId);
                    replayAnimationId = null;
                }
            } else {
                // Play
                if (replayState.isFinished) {
                    // Restart from beginning
                    processKeystrokesUpTo(0);
                    replayState.isFinished = false;
                }
                replayState.isPlaying = true;
                replayState.lastFrameTime = performance.now();
                playIcon.style.display = 'none';
                pauseIcon.style.display = 'block';
                replayAnimationId = requestAnimationFrame(replayLoop);
            }
        });
        
        // Scrubber input
        replayScrubber.addEventListener('input', (e) => {
            if (!replayState) return;
            
            const targetTime = parseFloat(e.target.value);
            processKeystrokesUpTo(targetTime);
        });
        
        // Pause while scrubbing
        replayScrubber.addEventListener('mousedown', () => {
            if (replayState && replayState.isPlaying) {
                replayState.isPlaying = false;
                playIcon.style.display = 'block';
                pauseIcon.style.display = 'none';
                if (replayAnimationId) {
                    cancelAnimationFrame(replayAnimationId);
                    replayAnimationId = null;
                }
            }
        });
        
        // Speed button
        const speeds = [1, 0.5, 0.25, 2, 4];
        let speedIndex = 0;
        replaySpeedBtn.addEventListener('click', () => {
            if (!replayState) return;
            
            speedIndex = (speedIndex + 1) % speeds.length;
            replayState.playbackSpeed = speeds[speedIndex];
            replaySpeedBtn.textContent = speeds[speedIndex] + 'x';
        });

        function closeReplay() {
            replayModal.classList.remove('visible');
            if (replayAnimationId) {
                cancelAnimationFrame(replayAnimationId);
                replayAnimationId = null;
            }
            replayState = null;
        }
        
        closeReplayBtn.addEventListener('click', closeReplay);
        replayModal.addEventListener('click', (e) => {
            if (e.target === replayModal) closeReplay();
        });
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && replayModal.classList.contains('visible')) {
                closeReplay();
            }
            // Space to play/pause
            if (e.key === ' ' && replayModal.classList.contains('visible') && replayState) {
                e.preventDefault();
                replayPlayBtn.click();
            }
        });

        // === SCROLL HANDLER ===
        function handleScroll() {
            const { scrollTop, scrollHeight, clientHeight } = listEl;
            const isNearBottom = scrollHeight - scrollTop <= clientHeight + 100;
            
            if (isNearBottom && !isLoading && hasMore) {
                loadMore();
            }
        }

        function checkFillScreen() {
            if (isLoading || !hasMore) return;
            
            // Check if content fills the screen, load more if not
            setTimeout(() => {
                const { scrollHeight, clientHeight } = listEl;
                if (scrollHeight <= clientHeight + 100) {
                    loadMore();
                }
            }, 100);
        }

        // === COUNTDOWN TIMER ===
        function updateCountdown() {
            countdownEl.textContent = getRemainingTimeUntilEnd();
        }

        // === INITIALIZATION ===
        function init() {
            // Get current user from localStorage (same key as main app)
            currentUser = localStorage.getItem('tpotracer_username') || 'guest';
            
            // Try to get high score from localStorage
            const storedHighScore = localStorage.getItem('tpotracer_high_score');
            userWpm = storedHighScore ? parseFloat(storedHighScore) : 0;
            
            // Initialize compact mode
            const savedCompactMode = localStorage.getItem('tpotracer_compact_mode') === 'true';
            compactToggle.checked = savedCompactMode;
            if (savedCompactMode) {
                leaderboardContainer.classList.add('compact-mode');
            }
            
            compactToggle.addEventListener('change', (e) => {
                const isCompact = e.target.checked;
                if (isCompact) {
                    leaderboardContainer.classList.add('compact-mode');
                } else {
                    leaderboardContainer.classList.remove('compact-mode');
                }
                localStorage.setItem('tpotracer_compact_mode', isCompact);
                checkFillScreen();
            });
            
            // Note: We don't have raw/acc in simple local storage key, so they will be null/'-'
            // unless found in leaderboard array during loadInitialData
            
            // Update countdown every second
            updateCountdown();
            setInterval(updateCountdown, 1000);
            
            // Setup scroll handler
            listEl.addEventListener('scroll', handleScroll);
            
            // Load initial data
            loadInitialData();
            
            // Refresh every 5 minutes
            setInterval(() => {
                loadInitialData();
            }, 5 * 60 * 1000);

            // Check for replay query param
            const urlParams = new URLSearchParams(window.location.search);
            const replayUser = urlParams.get('replay');
            if (replayUser) {
                // specific replay request
                setTimeout(() => {
                    openReplay(replayUser);
                }, 100);
            }
        }

        // Start when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
